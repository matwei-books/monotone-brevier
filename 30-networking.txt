
.. vim: set sw=2 ts=2 tw=78 et si:

Verteilt über das Netz
======================

Vorbereiten
-----------

Alle im Repository abgelegten Daten werden mit kryptographischen Schlüsseln
signiert. Das ist ein grundlegendes Element dieses Versionsverwaltungssystems.
Wenn ich gemeinsam mit anderen arbeiten will, muss ich deren Schlüssel kennen
und akzeptieren genauso wie sie meinen Schlüssel kennen und akzeptieren
müssen. Der erste Schritt zur Zusammenarbeit ist daher der Austausch der
Schlüssel::

 $ mtn pubkey mathias@weidner.in-bad-schmiedeberg.de \
   > mathias.pubkey

Für meinen eigenen Schlüssel muss ich dabei keine Datenbank angeben. Ich kann
diesen Schlüssel nun an alle Mitarbeiter schicken, die mir ihre öffentliche
Schlüssel senden und meinen Schlüssel importieren::

 $ mtn --db lokales/repository.mtn read < mathias.pubkey

Beim Import muss immer eine Datenbank angegeben werden, weil das Vertrauen
gegenüber fremden Schlüsseln immer projektbezogen ist. Nun kennt Monotone also
die Schlüssel aller Beteiligten, das reicht aber noch nicht ganz.

Damit der Monotone-Server Daten, die mit anderen (wenn auch bekannten)
Schlüsseln signiert wurden akzeptiert, muss ich diesen Schlüsseln noch ein
paar Rechte einräumen::

 $ cat >> ~/.monotone/read-permissions <<EOT
 pattern "*"
 allow "mathias@weidner.in-bad-schmiedeberg.de"
 EOT

Damit wird dem Schlüssel mathias@weidner.in-bad-schmiedeberg.de erlaubt, alle
Zweige in dem betreffenden Repository zu lesen, d.h. in ein anderes Repository
zu kopieren (z.B. mit ``mtn pull``).

Außerdem brauche ich noch Schreibzugriff, damit ich meine Daten in das
Repository schicken kann (``mtn push`` bzw. ``mtn sync``)::

 $ cat >> ~/.monotone/write-permissions <<EOT
 mathias@weidner.in-bad-schmiedeberg.de
 EOT

Bei den Schreibrechten wird nicht nach Zweig unterschieden.

Damit haben haben wir die Vorbereitungen abgeschlossen und können einen
Monotone Server starten, mit dem die anderen Mitarbeiter ihre Repositories
synchronisieren können.

Abgleich über Netz
------------------

Dieser Teil ist nun wieder sehr simpel. Damit andere sich mit meinem
Monotone-Repository abgleichen können, starte ich den Server wie folgt::

 $ mtn --db lokales/repository.mtn serve

Damit lauscht Monotone am TCP Port 4691 und bietet alles aus der Datenbank
``lokales/repository.mtn`` entsprechend den in
``read-permissions`` und ``write-permissions`` eingestellten Regeln an.

Um sich Daten von diesem Server zu holen, gibt man ein::

 $ mtn --db anderes/repository.mtn pull rechner.von.mathias "*"

Dabei kann man statt ``"*"`` auch direkt den Namen des Zweigs angeben oder ein
geeignetes Muster, dass alle gewünschten Zweige erfasst.

Wenn man schon einen eigenen, eventuell geänderten Stand hat, will man eher
beide Repositories auf den gleichen Stand bringen::

 $ mtn --db anderes/repository.mtn sync rechner.von.mathias "*"
 
bzw.

 $ mtn --db anderes/repository.mtn sync

Der zweite Aufruf ist möglich, wenn bereits einmal mit dem Rechner
synchronisiert wurde und dieser als ``default-server`` in der Datenbank
vermerkt ist (siehe ``mtn list vars``).

Wenn ich nur Änderungen auf den Server schieben will, nehme ich::

 $ mtn --db anderes/repository.mtn push

Die Anmerkungen wie zu ``mtn sync`` gelten auch hier.

Zentraler Server
----------------

Ein Grundprinzip von verteilten Versionsverwaltungssystemen wie Monotone ist
das, das ein zentraler Server nicht nötig ist.

Wenn mehrere Leute an einem Projekt arbeiten, insbesondere wenn die Mitarbeiter
räumlich oder zeitlich getrennt sind, ist es trotzdem praktisch ein Repository
zu haben, das immer an der gleichen Stelle über das Netz zu erreichen ist.
Dann wird dieses wie ein zentrales Repository verwendet und der Abgleich
zwischen den Entwicklern kann darüber erfolgen.  Ist der zentrale Server einmal
nicht zu erreichen, ist immer noch der direkte Abgleich zwischen den
Entwicklern möglich.

Ein weiterer Vorteil eines zentralen Servers ist der, dass man zum
Synchronisieren nur noch ``mtn sync`` eingeben muss und den Servernamen und
Zweig weglassen kann, wenn die betreffenden Variablen in der Datenbank richtig
eingestellt sind. Konkret sind das die Variablen ``database: default-server``
und ``database: default-include-pattern``. Diese sehen ungefähr so aus::

 $ mtn list vars
 database: default-exclude-pattern 
 database: default-include-pattern net.mamawe.text.monotone...
 database: default-server monotone.mamawe.net
 known-servers: monotone.mamawe.net b1c3782090a03536fc21f9f...

Die Variable ``known-servers: monotone.mamawe.net`` enthält den Schlüssel, für
den Monotone-Server. Dieser Schlüssel wird nicht für das Signieren der Dateien
im Repository sondern nur für die Kommunikation mit dem Server verwendet.
Falls sich der Schlüssel auf dem Server ändert, teilt mir das Monotone bei der
nächsten Verbindungsaufnahme mit. Damit ist die Gefahr geringer, dass ich mit
dem falschen Server synchronisiere.

Unter Debian GNU/Linux gibt es ein Paket ``monotone-server``, welches Scripts
enthält, die das Aufsetzen eines Monotone-Servers vereinfachen.

Der Server benötigt keine eigene Datensicherung, da alle Versionen, die er
enthält auch auf den Rechnern der Entwickler vorhanden sind. Bei einem Ausfall
kann ein neues Repository jederzeit aus einem der anderen Repositories,
welches alle Zweige und die letzten Änderungen enthält, neu aufgesetzt werden.
Lediglich der private Schlüssel für den Server sollte an einem sicheren Ort
verwahrt werden, damit beim Neuaufsetzen mit dem gleichen Schlüssel
weitergearbeitet werden kann und die beteiligten Entwickler keine Meldung über
geänderte Serverschlüssel bei der Synchronisation bekommen.

Anonymer Download
-----------------

Insbesondere bei Open Source Entwicklungen möchte man ein Repository gern zum
einfachen Download der Quellen freigeben. Das wird in
``read-permissions``  eingestellt::

 $ cat >> ~/.monotone/read-permissions <<EOT
 pattern "net.mamawe"
 allow "*"
 continue "true"

 pattern "*"
 allow "mathias@weidner.in-bad-schmiedeberg.de"
 EOT

Andere Transportwege
--------------------

Monotones Datenbanksynchronisation basiert auf einem Protokoll namens
*netsync*. Normalerweise transportiert Monotone dieses Protokoll über eine
einfache TCP-Verbindung. Das ist nicht der einzige Transportweg, über den
Monotone *netsync* verwenden kann. Es ist möglich dieses Protokoll über *SSH*
oder irgendein Programm, das eine Full-Duplex-Verbindung aufbauen kann, zu
verwenden.

Wenn Monotone mit dem *pull*, *push* oder *sync* Befehl aufgerufen wird,
reicht es das erste Argument an einen Lua-Hook weiter, der es in einen
Verbindungsbefehl umwandeln soll. Wenn dieser Hook einen Verbindungsbefehl
zurückliefert, startet Monotone diesen Befehl lokal und spricht das *netsync*
Protokoll über die Standardeingabe und -ausgabe des entsprechenden Processes.

Wenn der Lua-Hook keinen Verbindungsbefehl liefert, versucht Monotone das
erste Argument als TCP-Adresse zu interpretieren (ein Rechnername mit einer
optionalen Portnummer), baut eine TCP-Verbindung dorthin auf und spricht
*netsync* über diese Verbindung.

Der Default-Lua-Hook versteht zwei URI-Schemata:

- SSH-URIs in der Form ``ssh://[user@]hostname[:port]/pfad/zur/db.mtn``
- Datei-URIs in der Form ``file:/pfad/zur/db.mtn``

Bei einer SSH-URI muss das Programm *ssh* lokal im Suchpfad für Programme zu
finden sein und das Program *mtn* auf dem entfernten Rechner.

Bei einer Datei-URI muss das Programm *mtn* lokal im Suchpfad für Programme zu
finden sein.

In beiden Fällen wird die Datenbank gesperrt, d.h. man benötigt Schreibrechte
auf die Datenbank, auch wenn man nur mit *pull* Daten holt und die Datenbank
nicht dauerhaft modifiziert. Außerdem wird für diese beiden Transporte die
Default-Authentisierung deaktiviert.

Um weitere Transportwege zu unterstützen, muss man die beiden Lua-Hooks
``get_netsync_connect_command`` und ``use_transport_auth`` anpassen.
