
.. vim: set sw=2 ts=2 tw=78 et si:

Anpassungen und Erweiterungen
=============================

Monotone nutzt die Programmiersprache *Lua* für Anpassungen und Erweiterungen.

Lua-Funktionen werden in *rcfiles* definiert, die bei jedem Lauf von monotone
gelesen werden. Als *rcfiles* werden verwendet:

- *~/.monotone/monotonerc* bzw. *%APPDATA%\\monotone\\monotonerc*
  (auf MS Windows)
- *_MTN/monotonerc* im aktuellen Arbeitsbereich
- Dateien, die mit ``--rcfile=Dateiname`` in der Kommandozeile angegeben
  werden
- alle Dateien in Verzeichnissen, die mit ``--rcfile=Verzeichnisname`` in der
  Kommandozeile angegeben werden

Zuerst wird die Datei *~/.monotone/monotonerc*, dann
*_MTN/monotonerc*, wenn vorhanden und schließlich die mit *--rcfile*
angegebenen in der Reihenfolge der Kommandozeile geladen.
Spätere Definitionen überschreiben dabei frühere.

Lua-Funktionen werden auf zwei Arten in monotone verwendet. Als *Hooks* und
als benutzerdefinierte Befehle. Beide Arten werden ausführlich auf der Website
von monotone beschrieben.

Lua-Hooks
---------

*Hooks* sind Lua-Funktionen, die von monotone an verschiedenen Stellen
aufgerufen werden. Monotone stellt Default-Definitionen für einige dieser
Funktionen bereit.
Für andere Hooks gibt es keine Definitionen, stattdessen wird ein
Default-Rückgabewert verwendet.

Für eigene Definitionen kann es hilfreich sein, den Code der alten Definition
zumindest teilweise zu verwenden. Das ist mit *Lua* mit folgendem Code
möglich::

 do
     local old_hook = default_hook
     function default_hook(arg)
         if not old_hook(arg) then
             -- do other stuff
         end
     end
 end

Die alte Definition von *default_hook* ist über die Variable *old_hook* nur
innerhalb des *do* Blocks verfügbar. Global, das heißt, für monotone ist
*default_hook* jetzt in dieser Funktion definiert.

Benutzerdefinierte Befehle
--------------------------

Monotone stellt eine Reihe von Hilfsfunktionen zur Verfügung, die nicht im
Standard-Lua zur Verfügung stehen. Eine dieser Funktionen ist::

 register_command(name, params, abstract, description, function)

Diese Funktion fügt einen Befehl *name* zu den Benutzerbefehlen von monotone
hinzu. Wenn dieser registrierte Befehl aufgerufen wird, wird monotone die mit
*function* bereitgestellte Definition aufrufen. Diese Funktion würde
üblicherweise ``mtn_automate`` (siehe unten) verwenden, um den Aufruf
abzuarbeiten.  *params* ist eine Zeichenkette mit der Liste der Parameter
für den Befehl. *abstract* ist eine kurze Beschreibung, *description* eine
längere Beschreibung des Benutzerbefehls. Bei ``mtn help`` werden *params*,
*abstract* und *description* ausgegeben.

Eine weitere wichtige Funktion ist::

 mtn_automate(command args... )

Diese Funktion ruft den Befehl ``automate command`` von monotone mit *args*
auf. Das Ergebnis ist ein *pair* (Lua), das besteht aus einem Boolean
(``true`` bei Erfolg) und einer Zeichenkette, die den Inhalt von ``stdout``
des Aufrufs von ``automate command`` enthält.

Diese Funktion ist nicht für den Gebrauch in normalen Lua-Hooks sondern eher
für Lua-Funktionen, die mit ``register_command`` registriert wurden.

Beachte, dass Tastatureingaben wie bei der
``--non-interactive`` Option von monotone deaktiviert sind.
Aktionen, die Operationen mit
passwortgeschützten Schlüsseln benötigen, werden daher nicht funktionieren, es
sei denn, dass der ``get_passphrase`` Hook eingerichtet wurde.

Externe Programme
-----------------

Einbetten der aktuellen Revision
................................

Bei einigen Versionsverwaltungssystemen - zum Beispiel RCS und CVS - gibt es
Schlüsselworte, die im Quelltext eingesetzt werden können und dann vom
Versionsverwaltungssystem durch die entsprechenden Werte, wie die Version
der Datei oder das Datum des Check in, ersetzt werden. So etwas gibt es bei
monotone nicht, so dass man sich hier im Bedarfsfall mit einem Script behilft,
das eine Datei automatisch generiert, die dann im Quelltext eingebunden wird.

So etwas habe ich bei diesem Text ebenfalls verwendet. Die Angaben zur Basis-
und aktuellen Revision werden durch folgendes Script generiert::

 -- version.lua - get base and current version
 
 mtn_au = io.popen('mtn automate get_base_revision_id')
 base_rev = mtn_au:read('*l')
 mtn_au = io.popen('mtn ls changed')
 changed = mtn_au:read('*a')
 if 0 == string.len(changed) then
     curr_rev = base_rev
 else
     mtn_au = io.popen('mtn automate get_current_revision_id')
     curr_rev = mtn_au:read('*l')
 end
 print(':Autor: Mathias Weidner')
 print(':Datum: ' .. os.date('%Y-%m-%d'))
 print(':Basisrevision: ' .. base_rev)
 print(':Aktuelle Revision: ' .. curr_rev)

Dieses Script wird im Makefile auf die folgende Art aufgerufen::

 revision.txt: $(SOURCES) $(IMAGES) preamble.tex Makefile
         lua bin/revision.lua > revision.txt

Anschließend wird die Datei *revision.txt* im Vorspann eingebunden::

 .. include:: revision.txt

Das Ergebnis ist auf Seite 3 diesen Textes zu sehen.

Ich gebe hier die Basis- und die aktuelle Revision aus, so dass klar wird

- auf welcher Revision im Repository der Text aufbaut (der Basisrevision)
- ob an dieser Revision Veränderungen vorgenommen wurden (dann sind Basis- und
  aktuelle Revision verschieden)

Das Programm, das ich hier verwende, ist in Lua geschrieben. Prinzipiell
sollte es möglich sein, das Programm so zu schreiben, das es als Rcfile
eingelesen werden kann und die Ausgabe durch einen benutzerdefinierten Befehl
erfolgt. Der Vorteil wäre, das man keinen zusätzlichen Lua-Interpreter
benötigt und statt dessen den in monotone vorhandenen verwendet. Das lasse ich
als Aufgabe für den interessierten Leser.
